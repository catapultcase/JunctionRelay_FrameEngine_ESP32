#include <SPI.h>

// Pin definitions for ESP32 S3 Feather (adjust to your wiring)
#define EPD_CS    10  // D10 - Chip Select
#define EPD_DC    9   // D9  - Data/Command  
#define EPD_RST   6   // D6  - Reset
#define EPD_BUSY  5   // D5  - Busy

// Display specifications for Waveshare 7.3inch E-Paper (E) - 6 color
#define EPD_WIDTH   800
#define EPD_HEIGHT  480
// Buffer size (4 bits per pixel = 2 pixels/byte)
#define EPD_BUFFER_SIZE ((EPD_WIDTH * EPD_HEIGHT) / 2)

// 6-color definitions (4 bits per pixel) - CORRECTED BASED ON CADRE PROJECT
// The Cadre project shows that index 4 is unused, so colors 4&5 map to 5&6
#define EPD_BLACK   0x00  // Index 0
#define EPD_WHITE   0x01  // Index 1
#define EPD_YELLOW  0x02  // Index 2
#define EPD_RED     0x03  // Index 3
// Index 4 is UNUSED - skip it
#define EPD_BLUE    0x05  // Index 5 (was 4 in display, but 4 is unused)
#define EPD_GREEN   0x06  // Index 6 (was 5 in display, but 4 is unused)

bool displayInitialized = false;

// === Hardware Interface Layer ===
void epd_digital_write(int pin, int value) { digitalWrite(pin, value); }
int  epd_digital_read(int pin)              { return digitalRead(pin); }
void epd_delay_ms(unsigned int ms)          { delay(ms); }

void epd_spi_transfer(unsigned char data) {
  epd_digital_write(EPD_CS, LOW);
  SPI.transfer(data);
  epd_digital_write(EPD_CS, HIGH);
}

void epd_send_command(unsigned char command) {
  epd_digital_write(EPD_DC, LOW);
  epd_spi_transfer(command);
}

void epd_send_data(unsigned char data) {
  epd_digital_write(EPD_DC, HIGH);
  epd_spi_transfer(data);
}

void epd_read_busy_h(void) {
  while (epd_digital_read(EPD_BUSY) == LOW) {
    epd_delay_ms(5);
  }
}

void epd_read_busy_l(void) {
  while (epd_digital_read(EPD_BUSY) == HIGH) {
    epd_delay_ms(5);
  }
}

void epd_reset(void) {
  epd_digital_write(EPD_RST, HIGH);
  epd_delay_ms(20);
  epd_digital_write(EPD_RST, LOW);
  epd_delay_ms(2);
  epd_digital_write(EPD_RST, HIGH);
  epd_delay_ms(20);
}

void epd_turn_on_display(void) {
  epd_send_command(0x12); // DISPLAY_REFRESH
  epd_send_data(0x01);
  epd_read_busy_h();

  epd_send_command(0x02); // POWER_OFF
  epd_send_data(0x00);
  epd_read_busy_h();
}

int epd_if_init(void) {
  pinMode(EPD_CS, OUTPUT);
  pinMode(EPD_RST, OUTPUT);
  pinMode(EPD_DC, OUTPUT);
  pinMode(EPD_BUSY, INPUT);
  SPI.begin();
  SPI.beginTransaction(SPISettings(2000000, MSBFIRST, SPI_MODE0));
  return 0;
}

// === CORRECTED E-Paper Driver Layer ===
// Based on GDEP073E01 driver from Cadre project - much more comprehensive!
void epd_send_init_sequence() {
  // Command Header - wake up display
  epd_send_command(0xAA);
  epd_send_data(0x49);
  epd_send_data(0x55);
  epd_send_data(0x20);
  epd_send_data(0x08);
  epd_send_data(0x09);
  epd_send_data(0x18);
  
  // Power Setting - critical for stable operation
  epd_send_command(0x01);
  epd_send_data(0x3F);
  epd_send_data(0x00);
  epd_send_data(0x32);
  epd_send_data(0x2A);
  epd_send_data(0x0E);
  epd_send_data(0x2A);
  
  // Panel Setting - CRITICAL for 6-color mode
  epd_send_command(0x00);
  epd_send_data(0x5F);  // 6-color mode with proper settings
  epd_send_data(0x69);
  
  // Power OFF Setting
  epd_send_command(0x03);
  epd_send_data(0x00);
  epd_send_data(0x54);
  epd_send_data(0x00);
  epd_send_data(0x44);
  
  // Booster Setting 1
  epd_send_command(0x05);
  epd_send_data(0x40);
  epd_send_data(0x1F);
  epd_send_data(0x1F);
  epd_send_data(0x2C);
  
  // Booster Setting 2  
  epd_send_command(0x06);
  epd_send_data(0x6F);
  epd_send_data(0x1F);
  epd_send_data(0x16);
  epd_send_data(0x25);
  
  // Booster Setting 3
  epd_send_command(0x08);
  epd_send_data(0x6F);
  epd_send_data(0x1F);
  epd_send_data(0x1F);
  epd_send_data(0x22);
  
  // PLL Setting
  epd_send_command(0x30);
  epd_send_data(0x02);
  epd_send_data(0x00);
  
  // Temperature Sensor Enable
  epd_send_command(0x41);
  epd_send_data(0x00);
  
  // VCOM Setting - important for contrast
  epd_send_command(0x50);
  epd_send_data(0x3F);
  
  // CDI Setting - CRITICAL for color accuracy
  epd_send_command(0x60);
  epd_send_data(0x02);
  epd_send_data(0x00);
  
  // Resolution Setting - MUST MATCH YOUR DISPLAY
  epd_send_command(0x61);
  epd_send_data(0x03);  // 800 pixels width (high byte)
  epd_send_data(0x20);  // 800 pixels width (low byte)  
  epd_send_data(0x01);  // 480 pixels height (high byte)
  epd_send_data(0xE0);  // 480 pixels height (low byte)
  
  // Additional display settings
  epd_send_command(0x82);
  epd_send_data(0x1E);
  
  epd_send_command(0x84);
  epd_send_data(0x01);
  
  epd_send_command(0x86);
  epd_send_data(0x00);
  
  epd_send_command(0xE0);
  epd_send_data(0x01);
  
  epd_send_command(0xE3);
  epd_send_data(0x2F);
  
  epd_send_command(0xE6);
  epd_send_data(0x00);
}

int epd_init(void) {
  if (epd_if_init() != 0) return -1;
  epd_reset();
  epd_read_busy_h();
  epd_delay_ms(30);
  epd_send_init_sequence();
  return 0;
}

// Clear display to a single color
void epd_clear(unsigned char color) {
  unsigned int W = (EPD_WIDTH % 4 == 0 ? EPD_WIDTH/4 : EPD_WIDTH/4+1);
  unsigned int H = EPD_HEIGHT;
  
  epd_send_command(0x04);  // Power ON
  epd_read_busy_h();
  
  epd_send_command(0x10);  // Data Start Transmission
  for (unsigned int j = 0; j < H; j++) {
    for (unsigned int i = 0; i < W; i++) {
      epd_send_data((color<<6)|(color<<4)|(color<<2)|color);
    }
  }
  epd_turn_on_display();
}

// CRITICAL: Color correction function based on Cadre project findings
uint8_t epd_correct_color(uint8_t color) {
  // Clamp color to valid range (0-5)
  if (color > 5) color = 5;
  
  // Skip unused index 4: colors 4&5 become 5&6
  if (color >= 4) color += 1;
  
  return color;
}

// Display raw buffer (4-bit pixels) - WITH COLOR CORRECTION
void epd_display(unsigned char *image) {
  unsigned int W = (EPD_WIDTH % 4 == 0 ? EPD_WIDTH/4 : EPD_WIDTH/4+1);
  unsigned int H = EPD_HEIGHT;
  
  epd_send_command(0x04);  // Power ON
  epd_read_busy_h();
  
  epd_send_command(0x10);  // Data Start Transmission
  for (unsigned int j = 0; j < H; j++) {
    for (unsigned int i = 0; i < W; i++) {
      // Extract and correct both pixels in the byte
      uint8_t byte_val = image[i + j * W];
      uint8_t pixel1 = epd_correct_color((byte_val >> 4) & 0x0F);
      uint8_t pixel2 = epd_correct_color(byte_val & 0x0F);
      epd_send_data((pixel1 << 4) | pixel2);
    }
  }
  epd_turn_on_display();
}

void epd_sleep(void) {
  epd_send_command(0x02);  // Power OFF
  epd_send_data(0x00);
  epd_send_command(0x07);  // Deep Sleep
  epd_send_data(0xA5);
}

// CORRECTED test pattern - should show distinct color bands
void showTestPattern() {
  if (!displayInitialized) return;
  
  unsigned int W = (EPD_WIDTH % 4 == 0 ? EPD_WIDTH/4 : EPD_WIDTH/4+1);
  unsigned int H = EPD_HEIGHT;
  
  epd_send_command(0x04);  // Power ON
  epd_read_busy_h();
  
  epd_send_command(0x10);  // Data Start Transmission
  
  for (unsigned int y = 0; y < H; y++) {
    uint8_t band = y / 80;  // 6 bands of 80 pixels each
    uint8_t pixel = 0;
    
    switch (band) {
      case 0: pixel = (EPD_BLACK<<4)|EPD_BLACK; break;     // Black band
      case 1: pixel = (EPD_WHITE<<4)|EPD_WHITE; break;     // White band  
      case 2: pixel = (EPD_YELLOW<<4)|EPD_YELLOW; break;   // Yellow band
      case 3: pixel = (EPD_RED<<4)|EPD_RED; break;         // Red band
      case 4: pixel = (EPD_BLUE<<4)|EPD_BLUE; break;       // Blue band
      default: pixel = (EPD_GREEN<<4)|EPD_GREEN; break;    // Green band
    }
    
    for (unsigned int x = 0; x < W; x++) {
      epd_send_data(pixel);
    }
  }
  epd_turn_on_display();
}

// === Application Layer ===
void setup() {
  Serial.begin(115200);
  delay(2000);

  // Initialize display
  if (epd_init() == 0) {
    displayInitialized = true;
    Serial.println("✅ Display initialized");
    showTestPattern();
  } else {
    Serial.println("❌ Display init failed");
  }
}

void loop() {
  delay(1000);
}